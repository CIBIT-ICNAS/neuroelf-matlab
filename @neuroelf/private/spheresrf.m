function srf = spheresrf(r, f, c, col, rsc, type)
% spheresrf  - create a new sphere SRF
%
% FORMAT:       srf = spheresrf([radius, factor, center, color, rsc, type])
%
% Input fields:
%
%       radius      radius in BV units (mm, default: 140)
%       factor      number of faces factor, 20 * (4 ^ f) (default: 6)
%       center      center of sphere (default: [128, 128, 128])
%       color       RGBA color (default: [1, 0.7, 0.3, 1]);
%       rsc         re-scale after each iteration (default: false)
%       type        either or 'bvqx', 'freesurfer', or {'neuroelf'}
%
% Output fields:
%
%       srf         valid SRF object with specified properties

% Version:  v1.1
% Build:    16031812
% Date:     Mar-18 2016, 12:13 PM EST
% Author:   Jochen Weber, SCAN Unit, Columbia University, NYC, NY, USA
% URL/Info: http://neuroelf.net/

% Copyright (c) 2010, 2014, 2016, Jochen Weber
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of Columbia University nor the
%       names of its contributors may be used to endorse or promote products
%       derived from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
% WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
% DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
% ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

% argument check
if nargin < 1 || ...
   ~isa(r, 'double') || ...
    numel(r) ~= 1 || ...
    isinf(r) || ...
    isnan(r) || ...
    r <= 0
    r = 140;
end
if nargin < 2 || ...
   ~isa(f, 'double') || ...
    numel(f) ~= 1 || ...
    isinf(f) || ...
    isnan(f) || ...
    f < 0 || ...
    f > 9
    f = 6;
else
    f = round(f);
end
if nargin < 3 || ...
   ~isa(c, 'double') || ...
    numel(c) ~= 3 || ...
    any(isinf(c) | isnan(c) | c < -512 | c > 512)
    c = [128, 128, 128];
else
    c = c(:)';
end
if nargin < 4 || ...
   ~isa(col, 'double') || ...
    numel(col) ~= 4 || ...
    any(isinf(col(:)) | isnan(col(:)) | col(:) < 0 | col(:) > 1)
    col = [1, 0.7, 0.3, 1];
else
    col = col(:)';
end
if nargin < 5 || ...
   ~islogical(rsc) || ...
    numel(rsc) ~= 1
    rsc = false;
end
if nargin < 6 || ...
   ~ischar(type) || ...
    isempty(type) || ...
   ~any(lower(type(1)) == 'bfn')
    type = 'n';
else
    type = lower(type(1));
end

% create output
srf = xff('new:srf');
numvert = 2 + 10 * (4 ^ f);
numsurf = 20 * (4 ^ f);
srf.NrOfVertices = numvert;
srf.NrOfTriangles = numsurf;
srf.MeshCenter = [128, 128, 128];
srf.ConvexRGBA = col;
srf.VertexNormal = zeros(numvert, 3);

% fill first 12 vertices neighbors
gr = (1 + sqrt(5)) / 2;
g1 = gr / sqrt(1 + gr * gr);
g2 = 1 / sqrt(1 + gr * gr);
g3 = 1 - g1 * g1;
g4 = sqrt(1 - (g3 * g3 + g1 * g1));
g5 = sqrt(1 - g4 * g4);
if type ~= 'f'
    vert(1:12, :) = [ ...
       -g2,   0,  g1; ...
        g2,   0,  g1; ...
       -g2,   0, -g1; ...
        g2,   0, -g1; ...
         0,  g1,  g2; ...
         0,  g1, -g2; ...
         0, -g1,  g2; ...
         0, -g1, -g2; ...
        g1,  g2,   0; ...
       -g1,  g2,   0; ...
        g1, -g2,   0; ...
       -g1, -g2,   0];
    tria = [ ...
         1,  2,  7; ...
         1,  5,  2; ...
         1,  7, 12; ...
         1, 10,  5; ...
         1, 12, 10; ...
         2,  5,  9; ...
         2,  9, 11; ...
         2, 11,  7; ...
         3,  4,  6; ...
         3,  6, 10; ...
         3,  8,  4; ...
         3, 10, 12; ...
         3, 12,  8; ...
         4,  8, 11; ...
         4,  9,  6; ...
         4, 11,  9; ...
         5,  6,  9; ...
         5, 10,  6; ...
         7,  8, 12; ...
         7, 11,  8];
else
    vert(1:12, :) = [ ...
         0,  -1,   0; ...
        g1, -g4, -g3; ...
         0, -g4, -g5; ...
       -g1, -g4, -g3; ...
       -g2, -g4,1-g3; ...
        g2, -g4,1-g3; ...
        g1,  g4,  g3; ...
        g2,  g4,g3-1; ...
       -g2,  g4,g3-1; ...
       -g1,  g4,  g3; ...
         0,  g4,  g5; ...
         0,   1,   0];
    tria = [ ...
         1,  4,  5; ...
         1,  5,  6; ...
         1,  6,  2; ...
         1,  2,  3; ...
         1,  3,  4; ...
         4,  9, 10; ...
         4, 10,  5; ...
         5, 10, 11; ...
         5, 11,  6; ...
         6, 11,  7; ...
         2,  7,  8; ...
         2,  8,  3; ...
         3,  8,  9; ...
         9, 12, 10; ...
        10, 12, 11; ...
         7, 12,  8; ...
         8, 12,  9; ...
         4,  3,  9; ...
         6,  7,  2; ...
        11, 12,  7];
end

% divide triangles
for dc = 1:f
    [tria, vert] = mesh_tridivide(tria, vert);
    if rsc
        vert = r .* (vert ./ (sqrt(sum(vert .* vert, 2)) * ones(1, 3)));
    end
end

% scale and move
if rsc
    vert = vert + ones(numvert, 1) * c;
else
    vert = r .* (vert ./ (sqrt(sum(vert .* vert, 2)) * ones(1, 3))) + ...
        ones(numvert, 1) * c;
end

% BV-style sphere
if type == 'b'
    try
        bvsph = load([neuroelf_path('srf') filesep 'bvsph.mat']);
        bvsph = bvsph.bvsph;
        bvinv = zeros(1, numvert);
        bvinv(bvsph(1:numvert)) = 1:numvert;
        nvert = vert(bvsph(1:numvert), :);
        tria = bvinv(tria);
        vert = nvert;
    catch ne_eo;
        warning('neuroelf:general:conversionError', ...
            'Error converting from NeuroElf to BVQX style SRF: %s', ne_eo.message);
    end
end

% put arrays into SRF
srf.VertexCoordinate = vert;
srf.TriangleVertex = tria;
srf.Neighbors = mesh_trianglestoneighbors(size(vert, 1), tria);
srf.VertexColor = zeros(numvert, 4);

% recalc normals
srf.RecalcNormals;
